*** Four Rule Calculate Big O *** 

Rule Book : 

- Rule 1 : Worst Case 
- Rule 2 : Remove Constant 
- Rule 3 : Different Term Of Inputs
- Rule 4 : Drop Non Dominants  

---------------------------------------------

* Rule 1 Worst Case * 

- គេគិតទៅលើកករណីដែលអាក្រក់បំផុត សម្រាប់ ស្វែររក function របស់យើង

Ex:

public static void main(String[] args) {
		String[] names = new String[] { "Nita","Dara", "Thida", "Dara", "Vichect","Piseth"};
		
		findName(names);

	}
	
	public static void findName(String[] names) {
		
		for (int i = 0; i < names.length; i++) {
			System.out.println("running: " + (i+1));
			if (names[i] == "Piseth") {
				System.out.println("Found Piseth");
			}
		}
	}

==> function findName យើងគិតថា វានៅចុងក្រោយគេបង្អស់ (ចុះក្រោយអាក្រក់បំផុតគឺ រកឃើញនៅចុះក្រោយគេ)​

* Rule 2 : Remove Constant * 

public static void main(String[] args) {
		int[] items = {2,3,5,6,7};
		
		printFirstItemThenFirstHalfThenSayHello100Time(items);

	}

	// O(n) 
	private static void printFirstItemThenFirstHalfThenSayHello100Time(int[] items) {
		System.out.println("Print First Item " + items[0]); // O(1)
		
		int middleItems = (int)Math.floor(items.length/2.0); // O(1)
		
		int index =0; //O(1)
		
		while(index <middleItems) {
			System.out.println(items[index]);
			index++;
		} // O(n/2)
		
		for(int i =0 ;i<100;i++) {
			System.out.println("Hello Camboida");
		} // O(100)
		
	}
	//BIG O = O(3 + 2x n/2 + 100) = O(n) 
	
	public static void compressBoxTwice(int[] boxes) {
		for(int x :boxes) {
			System.out.println(x); // o(n)
		}
		
		for(int x :boxes) {
			System.out.println(x+"#"); // o(n)
		}
		
		//BigO = O(2n) => O(n) (n^2) 
	}

------------------------------------------------------------------------------

* Rule 3 : Different Term of Input * 


Ex1: BIG O(n+m)  

public static void compressBoxTwice(int[] boxes1, int[] boxes2) {
		for (int x : boxes1) {
			System.out.println(x); // o(n)
		}

		for (int x : boxes2) {
			System.out.println(x + "#"); // o(m)
		}
		// BigO(n+m)
	}

វាមាន Input 2 ផ្សេងគ្នាវាមិនទាក់ទងគ្នាទេ ចឹងវាមានរាងជាង BigO (n + m)

Ex2: BIG O(n^2):

int[] items = { 2, 4, 5, 6 };
		// want to print : (2,2), (2,4), (2,5), (2,6)
		
		printPairOfElement(items);



public static void printPairOfElement(int[] items) {
		for (int i = 0; i < items.length; i++) { //O(n)
			for (int j = 0; j < items.length; j++) { // O(n)
				System.out.println("("+items[i]+","+items[j]+")");
			}
		}
	}


--------------------------------------------------------------------------------

* Rule 4 : Drop Non Dominants * លុបចោលរបស់ដែលតិច

-  Dominants : លេចធ្លោ, លើសលុប 













































































